// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/tauki/invoiceexchange/ent/balance"
	"github.com/tauki/invoiceexchange/ent/bid"
	"github.com/tauki/invoiceexchange/ent/investor"
	"github.com/tauki/invoiceexchange/ent/invoice"
	"github.com/tauki/invoiceexchange/ent/invoiceitem"
	"github.com/tauki/invoiceexchange/ent/issuer"
	"github.com/tauki/invoiceexchange/ent/ledger"
	"github.com/tauki/invoiceexchange/ent/predicate"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBalance     = "Balance"
	TypeBid         = "Bid"
	TypeInvestor    = "Investor"
	TypeInvoice     = "Invoice"
	TypeInvoiceItem = "InvoiceItem"
	TypeIssuer      = "Issuer"
	TypeLedger      = "Ledger"
)

// BalanceMutation represents an operation that mutates the Balance nodes in the graph.
type BalanceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	total_amount        *float64
	addtotal_amount     *float64
	available_amount    *float64
	addavailable_amount *float64
	entity_id           *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	investor            map[uuid.UUID]struct{}
	removedinvestor     map[uuid.UUID]struct{}
	clearedinvestor     bool
	issuer              map[uuid.UUID]struct{}
	removedissuer       map[uuid.UUID]struct{}
	clearedissuer       bool
	done                bool
	oldValue            func(context.Context) (*Balance, error)
	predicates          []predicate.Balance
}

var _ ent.Mutation = (*BalanceMutation)(nil)

// balanceOption allows management of the mutation configuration using functional options.
type balanceOption func(*BalanceMutation)

// newBalanceMutation creates new mutation for the Balance entity.
func newBalanceMutation(c config, op Op, opts ...balanceOption) *BalanceMutation {
	m := &BalanceMutation{
		config:        c,
		op:            op,
		typ:           TypeBalance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBalanceID sets the ID field of the mutation.
func withBalanceID(id uuid.UUID) balanceOption {
	return func(m *BalanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Balance
		)
		m.oldValue = func(ctx context.Context) (*Balance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Balance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBalance sets the old Balance of the mutation.
func withBalance(node *Balance) balanceOption {
	return func(m *BalanceMutation) {
		m.oldValue = func(context.Context) (*Balance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BalanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BalanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Balance entities.
func (m *BalanceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BalanceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BalanceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Balance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTotalAmount sets the "total_amount" field.
func (m *BalanceMutation) SetTotalAmount(f float64) {
	m.total_amount = &f
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *BalanceMutation) TotalAmount() (r float64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldTotalAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds f to the "total_amount" field.
func (m *BalanceMutation) AddTotalAmount(f float64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += f
	} else {
		m.addtotal_amount = &f
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *BalanceMutation) AddedTotalAmount() (r float64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *BalanceMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
}

// SetAvailableAmount sets the "available_amount" field.
func (m *BalanceMutation) SetAvailableAmount(f float64) {
	m.available_amount = &f
	m.addavailable_amount = nil
}

// AvailableAmount returns the value of the "available_amount" field in the mutation.
func (m *BalanceMutation) AvailableAmount() (r float64, exists bool) {
	v := m.available_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableAmount returns the old "available_amount" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldAvailableAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableAmount: %w", err)
	}
	return oldValue.AvailableAmount, nil
}

// AddAvailableAmount adds f to the "available_amount" field.
func (m *BalanceMutation) AddAvailableAmount(f float64) {
	if m.addavailable_amount != nil {
		*m.addavailable_amount += f
	} else {
		m.addavailable_amount = &f
	}
}

// AddedAvailableAmount returns the value that was added to the "available_amount" field in this mutation.
func (m *BalanceMutation) AddedAvailableAmount() (r float64, exists bool) {
	v := m.addavailable_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableAmount resets all changes to the "available_amount" field.
func (m *BalanceMutation) ResetAvailableAmount() {
	m.available_amount = nil
	m.addavailable_amount = nil
}

// SetEntityID sets the "entity_id" field.
func (m *BalanceMutation) SetEntityID(u uuid.UUID) {
	m.entity_id = &u
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *BalanceMutation) EntityID() (r uuid.UUID, exists bool) {
	v := m.entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldEntityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *BalanceMutation) ResetEntityID() {
	m.entity_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BalanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BalanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BalanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BalanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BalanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BalanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddInvestorIDs adds the "investor" edge to the Investor entity by ids.
func (m *BalanceMutation) AddInvestorIDs(ids ...uuid.UUID) {
	if m.investor == nil {
		m.investor = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.investor[ids[i]] = struct{}{}
	}
}

// ClearInvestor clears the "investor" edge to the Investor entity.
func (m *BalanceMutation) ClearInvestor() {
	m.clearedinvestor = true
}

// InvestorCleared reports if the "investor" edge to the Investor entity was cleared.
func (m *BalanceMutation) InvestorCleared() bool {
	return m.clearedinvestor
}

// RemoveInvestorIDs removes the "investor" edge to the Investor entity by IDs.
func (m *BalanceMutation) RemoveInvestorIDs(ids ...uuid.UUID) {
	if m.removedinvestor == nil {
		m.removedinvestor = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.investor, ids[i])
		m.removedinvestor[ids[i]] = struct{}{}
	}
}

// RemovedInvestor returns the removed IDs of the "investor" edge to the Investor entity.
func (m *BalanceMutation) RemovedInvestorIDs() (ids []uuid.UUID) {
	for id := range m.removedinvestor {
		ids = append(ids, id)
	}
	return
}

// InvestorIDs returns the "investor" edge IDs in the mutation.
func (m *BalanceMutation) InvestorIDs() (ids []uuid.UUID) {
	for id := range m.investor {
		ids = append(ids, id)
	}
	return
}

// ResetInvestor resets all changes to the "investor" edge.
func (m *BalanceMutation) ResetInvestor() {
	m.investor = nil
	m.clearedinvestor = false
	m.removedinvestor = nil
}

// AddIssuerIDs adds the "issuer" edge to the Issuer entity by ids.
func (m *BalanceMutation) AddIssuerIDs(ids ...uuid.UUID) {
	if m.issuer == nil {
		m.issuer = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.issuer[ids[i]] = struct{}{}
	}
}

// ClearIssuer clears the "issuer" edge to the Issuer entity.
func (m *BalanceMutation) ClearIssuer() {
	m.clearedissuer = true
}

// IssuerCleared reports if the "issuer" edge to the Issuer entity was cleared.
func (m *BalanceMutation) IssuerCleared() bool {
	return m.clearedissuer
}

// RemoveIssuerIDs removes the "issuer" edge to the Issuer entity by IDs.
func (m *BalanceMutation) RemoveIssuerIDs(ids ...uuid.UUID) {
	if m.removedissuer == nil {
		m.removedissuer = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.issuer, ids[i])
		m.removedissuer[ids[i]] = struct{}{}
	}
}

// RemovedIssuer returns the removed IDs of the "issuer" edge to the Issuer entity.
func (m *BalanceMutation) RemovedIssuerIDs() (ids []uuid.UUID) {
	for id := range m.removedissuer {
		ids = append(ids, id)
	}
	return
}

// IssuerIDs returns the "issuer" edge IDs in the mutation.
func (m *BalanceMutation) IssuerIDs() (ids []uuid.UUID) {
	for id := range m.issuer {
		ids = append(ids, id)
	}
	return
}

// ResetIssuer resets all changes to the "issuer" edge.
func (m *BalanceMutation) ResetIssuer() {
	m.issuer = nil
	m.clearedissuer = false
	m.removedissuer = nil
}

// Where appends a list predicates to the BalanceMutation builder.
func (m *BalanceMutation) Where(ps ...predicate.Balance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BalanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BalanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Balance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BalanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BalanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Balance).
func (m *BalanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BalanceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.total_amount != nil {
		fields = append(fields, balance.FieldTotalAmount)
	}
	if m.available_amount != nil {
		fields = append(fields, balance.FieldAvailableAmount)
	}
	if m.entity_id != nil {
		fields = append(fields, balance.FieldEntityID)
	}
	if m.created_at != nil {
		fields = append(fields, balance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, balance.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BalanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case balance.FieldTotalAmount:
		return m.TotalAmount()
	case balance.FieldAvailableAmount:
		return m.AvailableAmount()
	case balance.FieldEntityID:
		return m.EntityID()
	case balance.FieldCreatedAt:
		return m.CreatedAt()
	case balance.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BalanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case balance.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case balance.FieldAvailableAmount:
		return m.OldAvailableAmount(ctx)
	case balance.FieldEntityID:
		return m.OldEntityID(ctx)
	case balance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case balance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Balance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case balance.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case balance.FieldAvailableAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableAmount(v)
		return nil
	case balance.FieldEntityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case balance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case balance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Balance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BalanceMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_amount != nil {
		fields = append(fields, balance.FieldTotalAmount)
	}
	if m.addavailable_amount != nil {
		fields = append(fields, balance.FieldAvailableAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BalanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case balance.FieldTotalAmount:
		return m.AddedTotalAmount()
	case balance.FieldAvailableAmount:
		return m.AddedAvailableAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case balance.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	case balance.FieldAvailableAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Balance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BalanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BalanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BalanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Balance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BalanceMutation) ResetField(name string) error {
	switch name {
	case balance.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case balance.FieldAvailableAmount:
		m.ResetAvailableAmount()
		return nil
	case balance.FieldEntityID:
		m.ResetEntityID()
		return nil
	case balance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case balance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Balance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BalanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.investor != nil {
		edges = append(edges, balance.EdgeInvestor)
	}
	if m.issuer != nil {
		edges = append(edges, balance.EdgeIssuer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BalanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case balance.EdgeInvestor:
		ids := make([]ent.Value, 0, len(m.investor))
		for id := range m.investor {
			ids = append(ids, id)
		}
		return ids
	case balance.EdgeIssuer:
		ids := make([]ent.Value, 0, len(m.issuer))
		for id := range m.issuer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BalanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinvestor != nil {
		edges = append(edges, balance.EdgeInvestor)
	}
	if m.removedissuer != nil {
		edges = append(edges, balance.EdgeIssuer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BalanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case balance.EdgeInvestor:
		ids := make([]ent.Value, 0, len(m.removedinvestor))
		for id := range m.removedinvestor {
			ids = append(ids, id)
		}
		return ids
	case balance.EdgeIssuer:
		ids := make([]ent.Value, 0, len(m.removedissuer))
		for id := range m.removedissuer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BalanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinvestor {
		edges = append(edges, balance.EdgeInvestor)
	}
	if m.clearedissuer {
		edges = append(edges, balance.EdgeIssuer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BalanceMutation) EdgeCleared(name string) bool {
	switch name {
	case balance.EdgeInvestor:
		return m.clearedinvestor
	case balance.EdgeIssuer:
		return m.clearedissuer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BalanceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Balance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BalanceMutation) ResetEdge(name string) error {
	switch name {
	case balance.EdgeInvestor:
		m.ResetInvestor()
		return nil
	case balance.EdgeIssuer:
		m.ResetIssuer()
		return nil
	}
	return fmt.Errorf("unknown Balance edge %s", name)
}

// BidMutation represents an operation that mutates the Bid nodes in the graph.
type BidMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	status             *bid.Status
	amount             *float64
	addamount          *float64
	accepted_amount    *float64
	addaccepted_amount *float64
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	invoice            *uuid.UUID
	clearedinvoice     bool
	investor           *uuid.UUID
	clearedinvestor    bool
	done               bool
	oldValue           func(context.Context) (*Bid, error)
	predicates         []predicate.Bid
}

var _ ent.Mutation = (*BidMutation)(nil)

// bidOption allows management of the mutation configuration using functional options.
type bidOption func(*BidMutation)

// newBidMutation creates new mutation for the Bid entity.
func newBidMutation(c config, op Op, opts ...bidOption) *BidMutation {
	m := &BidMutation{
		config:        c,
		op:            op,
		typ:           TypeBid,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBidID sets the ID field of the mutation.
func withBidID(id uuid.UUID) bidOption {
	return func(m *BidMutation) {
		var (
			err   error
			once  sync.Once
			value *Bid
		)
		m.oldValue = func(ctx context.Context) (*Bid, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bid.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBid sets the old Bid of the mutation.
func withBid(node *Bid) bidOption {
	return func(m *BidMutation) {
		m.oldValue = func(context.Context) (*Bid, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BidMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BidMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bid entities.
func (m *BidMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BidMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BidMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bid.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *BidMutation) SetStatus(b bid.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BidMutation) Status() (r bid.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Bid entity.
// If the Bid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BidMutation) OldStatus(ctx context.Context) (v bid.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BidMutation) ResetStatus() {
	m.status = nil
}

// SetAmount sets the "amount" field.
func (m *BidMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *BidMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Bid entity.
// If the Bid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BidMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *BidMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *BidMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *BidMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetAcceptedAmount sets the "accepted_amount" field.
func (m *BidMutation) SetAcceptedAmount(f float64) {
	m.accepted_amount = &f
	m.addaccepted_amount = nil
}

// AcceptedAmount returns the value of the "accepted_amount" field in the mutation.
func (m *BidMutation) AcceptedAmount() (r float64, exists bool) {
	v := m.accepted_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedAmount returns the old "accepted_amount" field's value of the Bid entity.
// If the Bid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BidMutation) OldAcceptedAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedAmount: %w", err)
	}
	return oldValue.AcceptedAmount, nil
}

// AddAcceptedAmount adds f to the "accepted_amount" field.
func (m *BidMutation) AddAcceptedAmount(f float64) {
	if m.addaccepted_amount != nil {
		*m.addaccepted_amount += f
	} else {
		m.addaccepted_amount = &f
	}
}

// AddedAcceptedAmount returns the value that was added to the "accepted_amount" field in this mutation.
func (m *BidMutation) AddedAcceptedAmount() (r float64, exists bool) {
	v := m.addaccepted_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAcceptedAmount resets all changes to the "accepted_amount" field.
func (m *BidMutation) ResetAcceptedAmount() {
	m.accepted_amount = nil
	m.addaccepted_amount = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BidMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BidMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bid entity.
// If the Bid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BidMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BidMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BidMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BidMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Bid entity.
// If the Bid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BidMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BidMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetInvoiceID sets the "invoice" edge to the Invoice entity by id.
func (m *BidMutation) SetInvoiceID(id uuid.UUID) {
	m.invoice = &id
}

// ClearInvoice clears the "invoice" edge to the Invoice entity.
func (m *BidMutation) ClearInvoice() {
	m.clearedinvoice = true
}

// InvoiceCleared reports if the "invoice" edge to the Invoice entity was cleared.
func (m *BidMutation) InvoiceCleared() bool {
	return m.clearedinvoice
}

// InvoiceID returns the "invoice" edge ID in the mutation.
func (m *BidMutation) InvoiceID() (id uuid.UUID, exists bool) {
	if m.invoice != nil {
		return *m.invoice, true
	}
	return
}

// InvoiceIDs returns the "invoice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoiceID instead. It exists only for internal usage by the builders.
func (m *BidMutation) InvoiceIDs() (ids []uuid.UUID) {
	if id := m.invoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoice resets all changes to the "invoice" edge.
func (m *BidMutation) ResetInvoice() {
	m.invoice = nil
	m.clearedinvoice = false
}

// SetInvestorID sets the "investor" edge to the Investor entity by id.
func (m *BidMutation) SetInvestorID(id uuid.UUID) {
	m.investor = &id
}

// ClearInvestor clears the "investor" edge to the Investor entity.
func (m *BidMutation) ClearInvestor() {
	m.clearedinvestor = true
}

// InvestorCleared reports if the "investor" edge to the Investor entity was cleared.
func (m *BidMutation) InvestorCleared() bool {
	return m.clearedinvestor
}

// InvestorID returns the "investor" edge ID in the mutation.
func (m *BidMutation) InvestorID() (id uuid.UUID, exists bool) {
	if m.investor != nil {
		return *m.investor, true
	}
	return
}

// InvestorIDs returns the "investor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvestorID instead. It exists only for internal usage by the builders.
func (m *BidMutation) InvestorIDs() (ids []uuid.UUID) {
	if id := m.investor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvestor resets all changes to the "investor" edge.
func (m *BidMutation) ResetInvestor() {
	m.investor = nil
	m.clearedinvestor = false
}

// Where appends a list predicates to the BidMutation builder.
func (m *BidMutation) Where(ps ...predicate.Bid) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BidMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BidMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bid, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BidMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BidMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bid).
func (m *BidMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BidMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.status != nil {
		fields = append(fields, bid.FieldStatus)
	}
	if m.amount != nil {
		fields = append(fields, bid.FieldAmount)
	}
	if m.accepted_amount != nil {
		fields = append(fields, bid.FieldAcceptedAmount)
	}
	if m.created_at != nil {
		fields = append(fields, bid.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bid.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BidMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bid.FieldStatus:
		return m.Status()
	case bid.FieldAmount:
		return m.Amount()
	case bid.FieldAcceptedAmount:
		return m.AcceptedAmount()
	case bid.FieldCreatedAt:
		return m.CreatedAt()
	case bid.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BidMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bid.FieldStatus:
		return m.OldStatus(ctx)
	case bid.FieldAmount:
		return m.OldAmount(ctx)
	case bid.FieldAcceptedAmount:
		return m.OldAcceptedAmount(ctx)
	case bid.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bid.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Bid field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BidMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bid.FieldStatus:
		v, ok := value.(bid.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bid.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case bid.FieldAcceptedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedAmount(v)
		return nil
	case bid.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bid.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Bid field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BidMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, bid.FieldAmount)
	}
	if m.addaccepted_amount != nil {
		fields = append(fields, bid.FieldAcceptedAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BidMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bid.FieldAmount:
		return m.AddedAmount()
	case bid.FieldAcceptedAmount:
		return m.AddedAcceptedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BidMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bid.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case bid.FieldAcceptedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAcceptedAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Bid numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BidMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BidMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BidMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bid nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BidMutation) ResetField(name string) error {
	switch name {
	case bid.FieldStatus:
		m.ResetStatus()
		return nil
	case bid.FieldAmount:
		m.ResetAmount()
		return nil
	case bid.FieldAcceptedAmount:
		m.ResetAcceptedAmount()
		return nil
	case bid.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bid.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Bid field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BidMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.invoice != nil {
		edges = append(edges, bid.EdgeInvoice)
	}
	if m.investor != nil {
		edges = append(edges, bid.EdgeInvestor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BidMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bid.EdgeInvoice:
		if id := m.invoice; id != nil {
			return []ent.Value{*id}
		}
	case bid.EdgeInvestor:
		if id := m.investor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BidMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BidMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BidMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinvoice {
		edges = append(edges, bid.EdgeInvoice)
	}
	if m.clearedinvestor {
		edges = append(edges, bid.EdgeInvestor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BidMutation) EdgeCleared(name string) bool {
	switch name {
	case bid.EdgeInvoice:
		return m.clearedinvoice
	case bid.EdgeInvestor:
		return m.clearedinvestor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BidMutation) ClearEdge(name string) error {
	switch name {
	case bid.EdgeInvoice:
		m.ClearInvoice()
		return nil
	case bid.EdgeInvestor:
		m.ClearInvestor()
		return nil
	}
	return fmt.Errorf("unknown Bid unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BidMutation) ResetEdge(name string) error {
	switch name {
	case bid.EdgeInvoice:
		m.ResetInvoice()
		return nil
	case bid.EdgeInvestor:
		m.ResetInvestor()
		return nil
	}
	return fmt.Errorf("unknown Bid edge %s", name)
}

// InvestorMutation represents an operation that mutates the Investor nodes in the graph.
type InvestorMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name            *string
	joined_at       *time.Time
	clearedFields   map[string]struct{}
	bids            map[uuid.UUID]struct{}
	removedbids     map[uuid.UUID]struct{}
	clearedbids     bool
	invoices        map[uuid.UUID]struct{}
	removedinvoices map[uuid.UUID]struct{}
	clearedinvoices bool
	balance         *uuid.UUID
	clearedbalance  bool
	done            bool
	oldValue        func(context.Context) (*Investor, error)
	predicates      []predicate.Investor
}

var _ ent.Mutation = (*InvestorMutation)(nil)

// investorOption allows management of the mutation configuration using functional options.
type investorOption func(*InvestorMutation)

// newInvestorMutation creates new mutation for the Investor entity.
func newInvestorMutation(c config, op Op, opts ...investorOption) *InvestorMutation {
	m := &InvestorMutation{
		config:        c,
		op:            op,
		typ:           TypeInvestor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvestorID sets the ID field of the mutation.
func withInvestorID(id uuid.UUID) investorOption {
	return func(m *InvestorMutation) {
		var (
			err   error
			once  sync.Once
			value *Investor
		)
		m.oldValue = func(ctx context.Context) (*Investor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Investor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvestor sets the old Investor of the mutation.
func withInvestor(node *Investor) investorOption {
	return func(m *InvestorMutation) {
		m.oldValue = func(context.Context) (*Investor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvestorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvestorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Investor entities.
func (m *InvestorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvestorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvestorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Investor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *InvestorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InvestorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Investor entity.
// If the Investor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InvestorMutation) ResetName() {
	m.name = nil
}

// SetJoinedAt sets the "joined_at" field.
func (m *InvestorMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *InvestorMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the Investor entity.
// If the Investor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestorMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *InvestorMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// AddBidIDs adds the "bids" edge to the Bid entity by ids.
func (m *InvestorMutation) AddBidIDs(ids ...uuid.UUID) {
	if m.bids == nil {
		m.bids = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bids[ids[i]] = struct{}{}
	}
}

// ClearBids clears the "bids" edge to the Bid entity.
func (m *InvestorMutation) ClearBids() {
	m.clearedbids = true
}

// BidsCleared reports if the "bids" edge to the Bid entity was cleared.
func (m *InvestorMutation) BidsCleared() bool {
	return m.clearedbids
}

// RemoveBidIDs removes the "bids" edge to the Bid entity by IDs.
func (m *InvestorMutation) RemoveBidIDs(ids ...uuid.UUID) {
	if m.removedbids == nil {
		m.removedbids = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bids, ids[i])
		m.removedbids[ids[i]] = struct{}{}
	}
}

// RemovedBids returns the removed IDs of the "bids" edge to the Bid entity.
func (m *InvestorMutation) RemovedBidsIDs() (ids []uuid.UUID) {
	for id := range m.removedbids {
		ids = append(ids, id)
	}
	return
}

// BidsIDs returns the "bids" edge IDs in the mutation.
func (m *InvestorMutation) BidsIDs() (ids []uuid.UUID) {
	for id := range m.bids {
		ids = append(ids, id)
	}
	return
}

// ResetBids resets all changes to the "bids" edge.
func (m *InvestorMutation) ResetBids() {
	m.bids = nil
	m.clearedbids = false
	m.removedbids = nil
}

// AddInvoiceIDs adds the "invoices" edge to the Invoice entity by ids.
func (m *InvestorMutation) AddInvoiceIDs(ids ...uuid.UUID) {
	if m.invoices == nil {
		m.invoices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invoices[ids[i]] = struct{}{}
	}
}

// ClearInvoices clears the "invoices" edge to the Invoice entity.
func (m *InvestorMutation) ClearInvoices() {
	m.clearedinvoices = true
}

// InvoicesCleared reports if the "invoices" edge to the Invoice entity was cleared.
func (m *InvestorMutation) InvoicesCleared() bool {
	return m.clearedinvoices
}

// RemoveInvoiceIDs removes the "invoices" edge to the Invoice entity by IDs.
func (m *InvestorMutation) RemoveInvoiceIDs(ids ...uuid.UUID) {
	if m.removedinvoices == nil {
		m.removedinvoices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invoices, ids[i])
		m.removedinvoices[ids[i]] = struct{}{}
	}
}

// RemovedInvoices returns the removed IDs of the "invoices" edge to the Invoice entity.
func (m *InvestorMutation) RemovedInvoicesIDs() (ids []uuid.UUID) {
	for id := range m.removedinvoices {
		ids = append(ids, id)
	}
	return
}

// InvoicesIDs returns the "invoices" edge IDs in the mutation.
func (m *InvestorMutation) InvoicesIDs() (ids []uuid.UUID) {
	for id := range m.invoices {
		ids = append(ids, id)
	}
	return
}

// ResetInvoices resets all changes to the "invoices" edge.
func (m *InvestorMutation) ResetInvoices() {
	m.invoices = nil
	m.clearedinvoices = false
	m.removedinvoices = nil
}

// SetBalanceID sets the "balance" edge to the Balance entity by id.
func (m *InvestorMutation) SetBalanceID(id uuid.UUID) {
	m.balance = &id
}

// ClearBalance clears the "balance" edge to the Balance entity.
func (m *InvestorMutation) ClearBalance() {
	m.clearedbalance = true
}

// BalanceCleared reports if the "balance" edge to the Balance entity was cleared.
func (m *InvestorMutation) BalanceCleared() bool {
	return m.clearedbalance
}

// BalanceID returns the "balance" edge ID in the mutation.
func (m *InvestorMutation) BalanceID() (id uuid.UUID, exists bool) {
	if m.balance != nil {
		return *m.balance, true
	}
	return
}

// BalanceIDs returns the "balance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BalanceID instead. It exists only for internal usage by the builders.
func (m *InvestorMutation) BalanceIDs() (ids []uuid.UUID) {
	if id := m.balance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBalance resets all changes to the "balance" edge.
func (m *InvestorMutation) ResetBalance() {
	m.balance = nil
	m.clearedbalance = false
}

// Where appends a list predicates to the InvestorMutation builder.
func (m *InvestorMutation) Where(ps ...predicate.Investor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvestorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvestorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Investor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvestorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvestorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Investor).
func (m *InvestorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvestorMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, investor.FieldName)
	}
	if m.joined_at != nil {
		fields = append(fields, investor.FieldJoinedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvestorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case investor.FieldName:
		return m.Name()
	case investor.FieldJoinedAt:
		return m.JoinedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvestorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case investor.FieldName:
		return m.OldName(ctx)
	case investor.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Investor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case investor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case investor.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Investor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvestorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvestorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Investor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvestorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvestorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvestorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Investor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvestorMutation) ResetField(name string) error {
	switch name {
	case investor.FieldName:
		m.ResetName()
		return nil
	case investor.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	}
	return fmt.Errorf("unknown Investor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvestorMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.bids != nil {
		edges = append(edges, investor.EdgeBids)
	}
	if m.invoices != nil {
		edges = append(edges, investor.EdgeInvoices)
	}
	if m.balance != nil {
		edges = append(edges, investor.EdgeBalance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvestorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case investor.EdgeBids:
		ids := make([]ent.Value, 0, len(m.bids))
		for id := range m.bids {
			ids = append(ids, id)
		}
		return ids
	case investor.EdgeInvoices:
		ids := make([]ent.Value, 0, len(m.invoices))
		for id := range m.invoices {
			ids = append(ids, id)
		}
		return ids
	case investor.EdgeBalance:
		if id := m.balance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvestorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbids != nil {
		edges = append(edges, investor.EdgeBids)
	}
	if m.removedinvoices != nil {
		edges = append(edges, investor.EdgeInvoices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvestorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case investor.EdgeBids:
		ids := make([]ent.Value, 0, len(m.removedbids))
		for id := range m.removedbids {
			ids = append(ids, id)
		}
		return ids
	case investor.EdgeInvoices:
		ids := make([]ent.Value, 0, len(m.removedinvoices))
		for id := range m.removedinvoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvestorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbids {
		edges = append(edges, investor.EdgeBids)
	}
	if m.clearedinvoices {
		edges = append(edges, investor.EdgeInvoices)
	}
	if m.clearedbalance {
		edges = append(edges, investor.EdgeBalance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvestorMutation) EdgeCleared(name string) bool {
	switch name {
	case investor.EdgeBids:
		return m.clearedbids
	case investor.EdgeInvoices:
		return m.clearedinvoices
	case investor.EdgeBalance:
		return m.clearedbalance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvestorMutation) ClearEdge(name string) error {
	switch name {
	case investor.EdgeBalance:
		m.ClearBalance()
		return nil
	}
	return fmt.Errorf("unknown Investor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvestorMutation) ResetEdge(name string) error {
	switch name {
	case investor.EdgeBids:
		m.ResetBids()
		return nil
	case investor.EdgeInvoices:
		m.ResetInvoices()
		return nil
	case investor.EdgeBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown Investor edge %s", name)
}

// InvoiceMutation represents an operation that mutates the Invoice nodes in the graph.
type InvoiceMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	status          *invoice.Status
	asking_price    *float64
	addasking_price *float64
	is_locked       *bool
	is_approved     *bool
	invoice_number  *string
	invoice_date    *time.Time
	due_date        *time.Time
	amount_due      *float64
	addamount_due   *float64
	customer_name   *string
	reference       *string
	company_name    *string
	currency        *string
	total_amount    *float64
	addtotal_amount *float64
	total_vat       *float64
	addtotal_vat    *float64
	created_at      *time.Time
	clearedFields   map[string]struct{}
	items           map[uuid.UUID]struct{}
	removeditems    map[uuid.UUID]struct{}
	cleareditems    bool
	bids            map[uuid.UUID]struct{}
	removedbids     map[uuid.UUID]struct{}
	clearedbids     bool
	issuer          *uuid.UUID
	clearedissuer   bool
	investor        map[uuid.UUID]struct{}
	removedinvestor map[uuid.UUID]struct{}
	clearedinvestor bool
	done            bool
	oldValue        func(context.Context) (*Invoice, error)
	predicates      []predicate.Invoice
}

var _ ent.Mutation = (*InvoiceMutation)(nil)

// invoiceOption allows management of the mutation configuration using functional options.
type invoiceOption func(*InvoiceMutation)

// newInvoiceMutation creates new mutation for the Invoice entity.
func newInvoiceMutation(c config, op Op, opts ...invoiceOption) *InvoiceMutation {
	m := &InvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoiceID sets the ID field of the mutation.
func withInvoiceID(id uuid.UUID) invoiceOption {
	return func(m *InvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Invoice
		)
		m.oldValue = func(ctx context.Context) (*Invoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoice sets the old Invoice of the mutation.
func withInvoice(node *Invoice) invoiceOption {
	return func(m *InvoiceMutation) {
		m.oldValue = func(context.Context) (*Invoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invoice entities.
func (m *InvoiceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoiceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoiceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *InvoiceMutation) SetStatus(i invoice.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *InvoiceMutation) Status() (r invoice.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldStatus(ctx context.Context) (v invoice.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InvoiceMutation) ResetStatus() {
	m.status = nil
}

// SetAskingPrice sets the "asking_price" field.
func (m *InvoiceMutation) SetAskingPrice(f float64) {
	m.asking_price = &f
	m.addasking_price = nil
}

// AskingPrice returns the value of the "asking_price" field in the mutation.
func (m *InvoiceMutation) AskingPrice() (r float64, exists bool) {
	v := m.asking_price
	if v == nil {
		return
	}
	return *v, true
}

// OldAskingPrice returns the old "asking_price" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldAskingPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAskingPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAskingPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAskingPrice: %w", err)
	}
	return oldValue.AskingPrice, nil
}

// AddAskingPrice adds f to the "asking_price" field.
func (m *InvoiceMutation) AddAskingPrice(f float64) {
	if m.addasking_price != nil {
		*m.addasking_price += f
	} else {
		m.addasking_price = &f
	}
}

// AddedAskingPrice returns the value that was added to the "asking_price" field in this mutation.
func (m *InvoiceMutation) AddedAskingPrice() (r float64, exists bool) {
	v := m.addasking_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetAskingPrice resets all changes to the "asking_price" field.
func (m *InvoiceMutation) ResetAskingPrice() {
	m.asking_price = nil
	m.addasking_price = nil
}

// SetIsLocked sets the "is_locked" field.
func (m *InvoiceMutation) SetIsLocked(b bool) {
	m.is_locked = &b
}

// IsLocked returns the value of the "is_locked" field in the mutation.
func (m *InvoiceMutation) IsLocked() (r bool, exists bool) {
	v := m.is_locked
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLocked returns the old "is_locked" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldIsLocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLocked: %w", err)
	}
	return oldValue.IsLocked, nil
}

// ResetIsLocked resets all changes to the "is_locked" field.
func (m *InvoiceMutation) ResetIsLocked() {
	m.is_locked = nil
}

// SetIsApproved sets the "is_approved" field.
func (m *InvoiceMutation) SetIsApproved(b bool) {
	m.is_approved = &b
}

// IsApproved returns the value of the "is_approved" field in the mutation.
func (m *InvoiceMutation) IsApproved() (r bool, exists bool) {
	v := m.is_approved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsApproved returns the old "is_approved" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldIsApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsApproved: %w", err)
	}
	return oldValue.IsApproved, nil
}

// ResetIsApproved resets all changes to the "is_approved" field.
func (m *InvoiceMutation) ResetIsApproved() {
	m.is_approved = nil
}

// SetInvoiceNumber sets the "invoice_number" field.
func (m *InvoiceMutation) SetInvoiceNumber(s string) {
	m.invoice_number = &s
}

// InvoiceNumber returns the value of the "invoice_number" field in the mutation.
func (m *InvoiceMutation) InvoiceNumber() (r string, exists bool) {
	v := m.invoice_number
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceNumber returns the old "invoice_number" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldInvoiceNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceNumber: %w", err)
	}
	return oldValue.InvoiceNumber, nil
}

// ResetInvoiceNumber resets all changes to the "invoice_number" field.
func (m *InvoiceMutation) ResetInvoiceNumber() {
	m.invoice_number = nil
}

// SetInvoiceDate sets the "invoice_date" field.
func (m *InvoiceMutation) SetInvoiceDate(t time.Time) {
	m.invoice_date = &t
}

// InvoiceDate returns the value of the "invoice_date" field in the mutation.
func (m *InvoiceMutation) InvoiceDate() (r time.Time, exists bool) {
	v := m.invoice_date
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDate returns the old "invoice_date" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldInvoiceDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDate: %w", err)
	}
	return oldValue.InvoiceDate, nil
}

// ResetInvoiceDate resets all changes to the "invoice_date" field.
func (m *InvoiceMutation) ResetInvoiceDate() {
	m.invoice_date = nil
}

// SetDueDate sets the "due_date" field.
func (m *InvoiceMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *InvoiceMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *InvoiceMutation) ResetDueDate() {
	m.due_date = nil
}

// SetAmountDue sets the "amount_due" field.
func (m *InvoiceMutation) SetAmountDue(f float64) {
	m.amount_due = &f
	m.addamount_due = nil
}

// AmountDue returns the value of the "amount_due" field in the mutation.
func (m *InvoiceMutation) AmountDue() (r float64, exists bool) {
	v := m.amount_due
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountDue returns the old "amount_due" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldAmountDue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountDue: %w", err)
	}
	return oldValue.AmountDue, nil
}

// AddAmountDue adds f to the "amount_due" field.
func (m *InvoiceMutation) AddAmountDue(f float64) {
	if m.addamount_due != nil {
		*m.addamount_due += f
	} else {
		m.addamount_due = &f
	}
}

// AddedAmountDue returns the value that was added to the "amount_due" field in this mutation.
func (m *InvoiceMutation) AddedAmountDue() (r float64, exists bool) {
	v := m.addamount_due
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountDue resets all changes to the "amount_due" field.
func (m *InvoiceMutation) ResetAmountDue() {
	m.amount_due = nil
	m.addamount_due = nil
}

// SetCustomerName sets the "customer_name" field.
func (m *InvoiceMutation) SetCustomerName(s string) {
	m.customer_name = &s
}

// CustomerName returns the value of the "customer_name" field in the mutation.
func (m *InvoiceMutation) CustomerName() (r string, exists bool) {
	v := m.customer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerName returns the old "customer_name" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCustomerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerName: %w", err)
	}
	return oldValue.CustomerName, nil
}

// ResetCustomerName resets all changes to the "customer_name" field.
func (m *InvoiceMutation) ResetCustomerName() {
	m.customer_name = nil
}

// SetReference sets the "reference" field.
func (m *InvoiceMutation) SetReference(s string) {
	m.reference = &s
}

// Reference returns the value of the "reference" field in the mutation.
func (m *InvoiceMutation) Reference() (r string, exists bool) {
	v := m.reference
	if v == nil {
		return
	}
	return *v, true
}

// OldReference returns the old "reference" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReference: %w", err)
	}
	return oldValue.Reference, nil
}

// ClearReference clears the value of the "reference" field.
func (m *InvoiceMutation) ClearReference() {
	m.reference = nil
	m.clearedFields[invoice.FieldReference] = struct{}{}
}

// ReferenceCleared returns if the "reference" field was cleared in this mutation.
func (m *InvoiceMutation) ReferenceCleared() bool {
	_, ok := m.clearedFields[invoice.FieldReference]
	return ok
}

// ResetReference resets all changes to the "reference" field.
func (m *InvoiceMutation) ResetReference() {
	m.reference = nil
	delete(m.clearedFields, invoice.FieldReference)
}

// SetCompanyName sets the "company_name" field.
func (m *InvoiceMutation) SetCompanyName(s string) {
	m.company_name = &s
}

// CompanyName returns the value of the "company_name" field in the mutation.
func (m *InvoiceMutation) CompanyName() (r string, exists bool) {
	v := m.company_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyName returns the old "company_name" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCompanyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyName: %w", err)
	}
	return oldValue.CompanyName, nil
}

// ClearCompanyName clears the value of the "company_name" field.
func (m *InvoiceMutation) ClearCompanyName() {
	m.company_name = nil
	m.clearedFields[invoice.FieldCompanyName] = struct{}{}
}

// CompanyNameCleared returns if the "company_name" field was cleared in this mutation.
func (m *InvoiceMutation) CompanyNameCleared() bool {
	_, ok := m.clearedFields[invoice.FieldCompanyName]
	return ok
}

// ResetCompanyName resets all changes to the "company_name" field.
func (m *InvoiceMutation) ResetCompanyName() {
	m.company_name = nil
	delete(m.clearedFields, invoice.FieldCompanyName)
}

// SetCurrency sets the "currency" field.
func (m *InvoiceMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *InvoiceMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *InvoiceMutation) ResetCurrency() {
	m.currency = nil
}

// SetTotalAmount sets the "total_amount" field.
func (m *InvoiceMutation) SetTotalAmount(f float64) {
	m.total_amount = &f
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *InvoiceMutation) TotalAmount() (r float64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldTotalAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds f to the "total_amount" field.
func (m *InvoiceMutation) AddTotalAmount(f float64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += f
	} else {
		m.addtotal_amount = &f
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *InvoiceMutation) AddedTotalAmount() (r float64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalAmount clears the value of the "total_amount" field.
func (m *InvoiceMutation) ClearTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
	m.clearedFields[invoice.FieldTotalAmount] = struct{}{}
}

// TotalAmountCleared returns if the "total_amount" field was cleared in this mutation.
func (m *InvoiceMutation) TotalAmountCleared() bool {
	_, ok := m.clearedFields[invoice.FieldTotalAmount]
	return ok
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *InvoiceMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
	delete(m.clearedFields, invoice.FieldTotalAmount)
}

// SetTotalVat sets the "total_vat" field.
func (m *InvoiceMutation) SetTotalVat(f float64) {
	m.total_vat = &f
	m.addtotal_vat = nil
}

// TotalVat returns the value of the "total_vat" field in the mutation.
func (m *InvoiceMutation) TotalVat() (r float64, exists bool) {
	v := m.total_vat
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalVat returns the old "total_vat" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldTotalVat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalVat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalVat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalVat: %w", err)
	}
	return oldValue.TotalVat, nil
}

// AddTotalVat adds f to the "total_vat" field.
func (m *InvoiceMutation) AddTotalVat(f float64) {
	if m.addtotal_vat != nil {
		*m.addtotal_vat += f
	} else {
		m.addtotal_vat = &f
	}
}

// AddedTotalVat returns the value that was added to the "total_vat" field in this mutation.
func (m *InvoiceMutation) AddedTotalVat() (r float64, exists bool) {
	v := m.addtotal_vat
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalVat clears the value of the "total_vat" field.
func (m *InvoiceMutation) ClearTotalVat() {
	m.total_vat = nil
	m.addtotal_vat = nil
	m.clearedFields[invoice.FieldTotalVat] = struct{}{}
}

// TotalVatCleared returns if the "total_vat" field was cleared in this mutation.
func (m *InvoiceMutation) TotalVatCleared() bool {
	_, ok := m.clearedFields[invoice.FieldTotalVat]
	return ok
}

// ResetTotalVat resets all changes to the "total_vat" field.
func (m *InvoiceMutation) ResetTotalVat() {
	m.total_vat = nil
	m.addtotal_vat = nil
	delete(m.clearedFields, invoice.FieldTotalVat)
}

// SetCreatedAt sets the "created_at" field.
func (m *InvoiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvoiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvoiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddItemIDs adds the "items" edge to the InvoiceItem entity by ids.
func (m *InvoiceMutation) AddItemIDs(ids ...uuid.UUID) {
	if m.items == nil {
		m.items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the InvoiceItem entity.
func (m *InvoiceMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the InvoiceItem entity was cleared.
func (m *InvoiceMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the InvoiceItem entity by IDs.
func (m *InvoiceMutation) RemoveItemIDs(ids ...uuid.UUID) {
	if m.removeditems == nil {
		m.removeditems = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the InvoiceItem entity.
func (m *InvoiceMutation) RemovedItemsIDs() (ids []uuid.UUID) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *InvoiceMutation) ItemsIDs() (ids []uuid.UUID) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *InvoiceMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddBidIDs adds the "bids" edge to the Bid entity by ids.
func (m *InvoiceMutation) AddBidIDs(ids ...uuid.UUID) {
	if m.bids == nil {
		m.bids = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bids[ids[i]] = struct{}{}
	}
}

// ClearBids clears the "bids" edge to the Bid entity.
func (m *InvoiceMutation) ClearBids() {
	m.clearedbids = true
}

// BidsCleared reports if the "bids" edge to the Bid entity was cleared.
func (m *InvoiceMutation) BidsCleared() bool {
	return m.clearedbids
}

// RemoveBidIDs removes the "bids" edge to the Bid entity by IDs.
func (m *InvoiceMutation) RemoveBidIDs(ids ...uuid.UUID) {
	if m.removedbids == nil {
		m.removedbids = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bids, ids[i])
		m.removedbids[ids[i]] = struct{}{}
	}
}

// RemovedBids returns the removed IDs of the "bids" edge to the Bid entity.
func (m *InvoiceMutation) RemovedBidsIDs() (ids []uuid.UUID) {
	for id := range m.removedbids {
		ids = append(ids, id)
	}
	return
}

// BidsIDs returns the "bids" edge IDs in the mutation.
func (m *InvoiceMutation) BidsIDs() (ids []uuid.UUID) {
	for id := range m.bids {
		ids = append(ids, id)
	}
	return
}

// ResetBids resets all changes to the "bids" edge.
func (m *InvoiceMutation) ResetBids() {
	m.bids = nil
	m.clearedbids = false
	m.removedbids = nil
}

// SetIssuerID sets the "issuer" edge to the Issuer entity by id.
func (m *InvoiceMutation) SetIssuerID(id uuid.UUID) {
	m.issuer = &id
}

// ClearIssuer clears the "issuer" edge to the Issuer entity.
func (m *InvoiceMutation) ClearIssuer() {
	m.clearedissuer = true
}

// IssuerCleared reports if the "issuer" edge to the Issuer entity was cleared.
func (m *InvoiceMutation) IssuerCleared() bool {
	return m.clearedissuer
}

// IssuerID returns the "issuer" edge ID in the mutation.
func (m *InvoiceMutation) IssuerID() (id uuid.UUID, exists bool) {
	if m.issuer != nil {
		return *m.issuer, true
	}
	return
}

// IssuerIDs returns the "issuer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssuerID instead. It exists only for internal usage by the builders.
func (m *InvoiceMutation) IssuerIDs() (ids []uuid.UUID) {
	if id := m.issuer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssuer resets all changes to the "issuer" edge.
func (m *InvoiceMutation) ResetIssuer() {
	m.issuer = nil
	m.clearedissuer = false
}

// AddInvestorIDs adds the "investor" edge to the Investor entity by ids.
func (m *InvoiceMutation) AddInvestorIDs(ids ...uuid.UUID) {
	if m.investor == nil {
		m.investor = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.investor[ids[i]] = struct{}{}
	}
}

// ClearInvestor clears the "investor" edge to the Investor entity.
func (m *InvoiceMutation) ClearInvestor() {
	m.clearedinvestor = true
}

// InvestorCleared reports if the "investor" edge to the Investor entity was cleared.
func (m *InvoiceMutation) InvestorCleared() bool {
	return m.clearedinvestor
}

// RemoveInvestorIDs removes the "investor" edge to the Investor entity by IDs.
func (m *InvoiceMutation) RemoveInvestorIDs(ids ...uuid.UUID) {
	if m.removedinvestor == nil {
		m.removedinvestor = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.investor, ids[i])
		m.removedinvestor[ids[i]] = struct{}{}
	}
}

// RemovedInvestor returns the removed IDs of the "investor" edge to the Investor entity.
func (m *InvoiceMutation) RemovedInvestorIDs() (ids []uuid.UUID) {
	for id := range m.removedinvestor {
		ids = append(ids, id)
	}
	return
}

// InvestorIDs returns the "investor" edge IDs in the mutation.
func (m *InvoiceMutation) InvestorIDs() (ids []uuid.UUID) {
	for id := range m.investor {
		ids = append(ids, id)
	}
	return
}

// ResetInvestor resets all changes to the "investor" edge.
func (m *InvoiceMutation) ResetInvestor() {
	m.investor = nil
	m.clearedinvestor = false
	m.removedinvestor = nil
}

// Where appends a list predicates to the InvoiceMutation builder.
func (m *InvoiceMutation) Where(ps ...predicate.Invoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invoice).
func (m *InvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoiceMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.status != nil {
		fields = append(fields, invoice.FieldStatus)
	}
	if m.asking_price != nil {
		fields = append(fields, invoice.FieldAskingPrice)
	}
	if m.is_locked != nil {
		fields = append(fields, invoice.FieldIsLocked)
	}
	if m.is_approved != nil {
		fields = append(fields, invoice.FieldIsApproved)
	}
	if m.invoice_number != nil {
		fields = append(fields, invoice.FieldInvoiceNumber)
	}
	if m.invoice_date != nil {
		fields = append(fields, invoice.FieldInvoiceDate)
	}
	if m.due_date != nil {
		fields = append(fields, invoice.FieldDueDate)
	}
	if m.amount_due != nil {
		fields = append(fields, invoice.FieldAmountDue)
	}
	if m.customer_name != nil {
		fields = append(fields, invoice.FieldCustomerName)
	}
	if m.reference != nil {
		fields = append(fields, invoice.FieldReference)
	}
	if m.company_name != nil {
		fields = append(fields, invoice.FieldCompanyName)
	}
	if m.currency != nil {
		fields = append(fields, invoice.FieldCurrency)
	}
	if m.total_amount != nil {
		fields = append(fields, invoice.FieldTotalAmount)
	}
	if m.total_vat != nil {
		fields = append(fields, invoice.FieldTotalVat)
	}
	if m.created_at != nil {
		fields = append(fields, invoice.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldStatus:
		return m.Status()
	case invoice.FieldAskingPrice:
		return m.AskingPrice()
	case invoice.FieldIsLocked:
		return m.IsLocked()
	case invoice.FieldIsApproved:
		return m.IsApproved()
	case invoice.FieldInvoiceNumber:
		return m.InvoiceNumber()
	case invoice.FieldInvoiceDate:
		return m.InvoiceDate()
	case invoice.FieldDueDate:
		return m.DueDate()
	case invoice.FieldAmountDue:
		return m.AmountDue()
	case invoice.FieldCustomerName:
		return m.CustomerName()
	case invoice.FieldReference:
		return m.Reference()
	case invoice.FieldCompanyName:
		return m.CompanyName()
	case invoice.FieldCurrency:
		return m.Currency()
	case invoice.FieldTotalAmount:
		return m.TotalAmount()
	case invoice.FieldTotalVat:
		return m.TotalVat()
	case invoice.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoice.FieldStatus:
		return m.OldStatus(ctx)
	case invoice.FieldAskingPrice:
		return m.OldAskingPrice(ctx)
	case invoice.FieldIsLocked:
		return m.OldIsLocked(ctx)
	case invoice.FieldIsApproved:
		return m.OldIsApproved(ctx)
	case invoice.FieldInvoiceNumber:
		return m.OldInvoiceNumber(ctx)
	case invoice.FieldInvoiceDate:
		return m.OldInvoiceDate(ctx)
	case invoice.FieldDueDate:
		return m.OldDueDate(ctx)
	case invoice.FieldAmountDue:
		return m.OldAmountDue(ctx)
	case invoice.FieldCustomerName:
		return m.OldCustomerName(ctx)
	case invoice.FieldReference:
		return m.OldReference(ctx)
	case invoice.FieldCompanyName:
		return m.OldCompanyName(ctx)
	case invoice.FieldCurrency:
		return m.OldCurrency(ctx)
	case invoice.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case invoice.FieldTotalVat:
		return m.OldTotalVat(ctx)
	case invoice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Invoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldStatus:
		v, ok := value.(invoice.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case invoice.FieldAskingPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAskingPrice(v)
		return nil
	case invoice.FieldIsLocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLocked(v)
		return nil
	case invoice.FieldIsApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsApproved(v)
		return nil
	case invoice.FieldInvoiceNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceNumber(v)
		return nil
	case invoice.FieldInvoiceDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDate(v)
		return nil
	case invoice.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case invoice.FieldAmountDue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountDue(v)
		return nil
	case invoice.FieldCustomerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerName(v)
		return nil
	case invoice.FieldReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReference(v)
		return nil
	case invoice.FieldCompanyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyName(v)
		return nil
	case invoice.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case invoice.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case invoice.FieldTotalVat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalVat(v)
		return nil
	case invoice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoiceMutation) AddedFields() []string {
	var fields []string
	if m.addasking_price != nil {
		fields = append(fields, invoice.FieldAskingPrice)
	}
	if m.addamount_due != nil {
		fields = append(fields, invoice.FieldAmountDue)
	}
	if m.addtotal_amount != nil {
		fields = append(fields, invoice.FieldTotalAmount)
	}
	if m.addtotal_vat != nil {
		fields = append(fields, invoice.FieldTotalVat)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldAskingPrice:
		return m.AddedAskingPrice()
	case invoice.FieldAmountDue:
		return m.AddedAmountDue()
	case invoice.FieldTotalAmount:
		return m.AddedTotalAmount()
	case invoice.FieldTotalVat:
		return m.AddedTotalVat()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldAskingPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAskingPrice(v)
		return nil
	case invoice.FieldAmountDue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountDue(v)
		return nil
	case invoice.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	case invoice.FieldTotalVat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalVat(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invoice.FieldReference) {
		fields = append(fields, invoice.FieldReference)
	}
	if m.FieldCleared(invoice.FieldCompanyName) {
		fields = append(fields, invoice.FieldCompanyName)
	}
	if m.FieldCleared(invoice.FieldTotalAmount) {
		fields = append(fields, invoice.FieldTotalAmount)
	}
	if m.FieldCleared(invoice.FieldTotalVat) {
		fields = append(fields, invoice.FieldTotalVat)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoiceMutation) ClearField(name string) error {
	switch name {
	case invoice.FieldReference:
		m.ClearReference()
		return nil
	case invoice.FieldCompanyName:
		m.ClearCompanyName()
		return nil
	case invoice.FieldTotalAmount:
		m.ClearTotalAmount()
		return nil
	case invoice.FieldTotalVat:
		m.ClearTotalVat()
		return nil
	}
	return fmt.Errorf("unknown Invoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoiceMutation) ResetField(name string) error {
	switch name {
	case invoice.FieldStatus:
		m.ResetStatus()
		return nil
	case invoice.FieldAskingPrice:
		m.ResetAskingPrice()
		return nil
	case invoice.FieldIsLocked:
		m.ResetIsLocked()
		return nil
	case invoice.FieldIsApproved:
		m.ResetIsApproved()
		return nil
	case invoice.FieldInvoiceNumber:
		m.ResetInvoiceNumber()
		return nil
	case invoice.FieldInvoiceDate:
		m.ResetInvoiceDate()
		return nil
	case invoice.FieldDueDate:
		m.ResetDueDate()
		return nil
	case invoice.FieldAmountDue:
		m.ResetAmountDue()
		return nil
	case invoice.FieldCustomerName:
		m.ResetCustomerName()
		return nil
	case invoice.FieldReference:
		m.ResetReference()
		return nil
	case invoice.FieldCompanyName:
		m.ResetCompanyName()
		return nil
	case invoice.FieldCurrency:
		m.ResetCurrency()
		return nil
	case invoice.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case invoice.FieldTotalVat:
		m.ResetTotalVat()
		return nil
	case invoice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.items != nil {
		edges = append(edges, invoice.EdgeItems)
	}
	if m.bids != nil {
		edges = append(edges, invoice.EdgeBids)
	}
	if m.issuer != nil {
		edges = append(edges, invoice.EdgeIssuer)
	}
	if m.investor != nil {
		edges = append(edges, invoice.EdgeInvestor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invoice.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case invoice.EdgeBids:
		ids := make([]ent.Value, 0, len(m.bids))
		for id := range m.bids {
			ids = append(ids, id)
		}
		return ids
	case invoice.EdgeIssuer:
		if id := m.issuer; id != nil {
			return []ent.Value{*id}
		}
	case invoice.EdgeInvestor:
		ids := make([]ent.Value, 0, len(m.investor))
		for id := range m.investor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeditems != nil {
		edges = append(edges, invoice.EdgeItems)
	}
	if m.removedbids != nil {
		edges = append(edges, invoice.EdgeBids)
	}
	if m.removedinvestor != nil {
		edges = append(edges, invoice.EdgeInvestor)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case invoice.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case invoice.EdgeBids:
		ids := make([]ent.Value, 0, len(m.removedbids))
		for id := range m.removedbids {
			ids = append(ids, id)
		}
		return ids
	case invoice.EdgeInvestor:
		ids := make([]ent.Value, 0, len(m.removedinvestor))
		for id := range m.removedinvestor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareditems {
		edges = append(edges, invoice.EdgeItems)
	}
	if m.clearedbids {
		edges = append(edges, invoice.EdgeBids)
	}
	if m.clearedissuer {
		edges = append(edges, invoice.EdgeIssuer)
	}
	if m.clearedinvestor {
		edges = append(edges, invoice.EdgeInvestor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case invoice.EdgeItems:
		return m.cleareditems
	case invoice.EdgeBids:
		return m.clearedbids
	case invoice.EdgeIssuer:
		return m.clearedissuer
	case invoice.EdgeInvestor:
		return m.clearedinvestor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoiceMutation) ClearEdge(name string) error {
	switch name {
	case invoice.EdgeIssuer:
		m.ClearIssuer()
		return nil
	}
	return fmt.Errorf("unknown Invoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoiceMutation) ResetEdge(name string) error {
	switch name {
	case invoice.EdgeItems:
		m.ResetItems()
		return nil
	case invoice.EdgeBids:
		m.ResetBids()
		return nil
	case invoice.EdgeIssuer:
		m.ResetIssuer()
		return nil
	case invoice.EdgeInvestor:
		m.ResetInvestor()
		return nil
	}
	return fmt.Errorf("unknown Invoice edge %s", name)
}

// InvoiceItemMutation represents an operation that mutates the InvoiceItem nodes in the graph.
type InvoiceItemMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	description    *string
	quantity       *int
	addquantity    *int
	unit_price     *float64
	addunit_price  *float64
	amount         *float64
	addamount      *float64
	vat_rate       *float64
	addvat_rate    *float64
	vat_amount     *float64
	addvat_amount  *float64
	clearedFields  map[string]struct{}
	invoice        *uuid.UUID
	clearedinvoice bool
	done           bool
	oldValue       func(context.Context) (*InvoiceItem, error)
	predicates     []predicate.InvoiceItem
}

var _ ent.Mutation = (*InvoiceItemMutation)(nil)

// invoiceitemOption allows management of the mutation configuration using functional options.
type invoiceitemOption func(*InvoiceItemMutation)

// newInvoiceItemMutation creates new mutation for the InvoiceItem entity.
func newInvoiceItemMutation(c config, op Op, opts ...invoiceitemOption) *InvoiceItemMutation {
	m := &InvoiceItemMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoiceItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoiceItemID sets the ID field of the mutation.
func withInvoiceItemID(id uuid.UUID) invoiceitemOption {
	return func(m *InvoiceItemMutation) {
		var (
			err   error
			once  sync.Once
			value *InvoiceItem
		)
		m.oldValue = func(ctx context.Context) (*InvoiceItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvoiceItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoiceItem sets the old InvoiceItem of the mutation.
func withInvoiceItem(node *InvoiceItem) invoiceitemOption {
	return func(m *InvoiceItemMutation) {
		m.oldValue = func(context.Context) (*InvoiceItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoiceItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoiceItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvoiceItem entities.
func (m *InvoiceItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoiceItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoiceItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvoiceItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *InvoiceItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *InvoiceItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the InvoiceItem entity.
// If the InvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *InvoiceItemMutation) ResetDescription() {
	m.description = nil
}

// SetQuantity sets the "quantity" field.
func (m *InvoiceItemMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *InvoiceItemMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the InvoiceItem entity.
// If the InvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceItemMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *InvoiceItemMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *InvoiceItemMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *InvoiceItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetUnitPrice sets the "unit_price" field.
func (m *InvoiceItemMutation) SetUnitPrice(f float64) {
	m.unit_price = &f
	m.addunit_price = nil
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *InvoiceItemMutation) UnitPrice() (r float64, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the InvoiceItem entity.
// If the InvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceItemMutation) OldUnitPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// AddUnitPrice adds f to the "unit_price" field.
func (m *InvoiceItemMutation) AddUnitPrice(f float64) {
	if m.addunit_price != nil {
		*m.addunit_price += f
	} else {
		m.addunit_price = &f
	}
}

// AddedUnitPrice returns the value that was added to the "unit_price" field in this mutation.
func (m *InvoiceItemMutation) AddedUnitPrice() (r float64, exists bool) {
	v := m.addunit_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *InvoiceItemMutation) ResetUnitPrice() {
	m.unit_price = nil
	m.addunit_price = nil
}

// SetAmount sets the "amount" field.
func (m *InvoiceItemMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *InvoiceItemMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the InvoiceItem entity.
// If the InvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceItemMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *InvoiceItemMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *InvoiceItemMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *InvoiceItemMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetVatRate sets the "vat_rate" field.
func (m *InvoiceItemMutation) SetVatRate(f float64) {
	m.vat_rate = &f
	m.addvat_rate = nil
}

// VatRate returns the value of the "vat_rate" field in the mutation.
func (m *InvoiceItemMutation) VatRate() (r float64, exists bool) {
	v := m.vat_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldVatRate returns the old "vat_rate" field's value of the InvoiceItem entity.
// If the InvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceItemMutation) OldVatRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVatRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVatRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVatRate: %w", err)
	}
	return oldValue.VatRate, nil
}

// AddVatRate adds f to the "vat_rate" field.
func (m *InvoiceItemMutation) AddVatRate(f float64) {
	if m.addvat_rate != nil {
		*m.addvat_rate += f
	} else {
		m.addvat_rate = &f
	}
}

// AddedVatRate returns the value that was added to the "vat_rate" field in this mutation.
func (m *InvoiceItemMutation) AddedVatRate() (r float64, exists bool) {
	v := m.addvat_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetVatRate resets all changes to the "vat_rate" field.
func (m *InvoiceItemMutation) ResetVatRate() {
	m.vat_rate = nil
	m.addvat_rate = nil
}

// SetVatAmount sets the "vat_amount" field.
func (m *InvoiceItemMutation) SetVatAmount(f float64) {
	m.vat_amount = &f
	m.addvat_amount = nil
}

// VatAmount returns the value of the "vat_amount" field in the mutation.
func (m *InvoiceItemMutation) VatAmount() (r float64, exists bool) {
	v := m.vat_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldVatAmount returns the old "vat_amount" field's value of the InvoiceItem entity.
// If the InvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceItemMutation) OldVatAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVatAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVatAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVatAmount: %w", err)
	}
	return oldValue.VatAmount, nil
}

// AddVatAmount adds f to the "vat_amount" field.
func (m *InvoiceItemMutation) AddVatAmount(f float64) {
	if m.addvat_amount != nil {
		*m.addvat_amount += f
	} else {
		m.addvat_amount = &f
	}
}

// AddedVatAmount returns the value that was added to the "vat_amount" field in this mutation.
func (m *InvoiceItemMutation) AddedVatAmount() (r float64, exists bool) {
	v := m.addvat_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetVatAmount resets all changes to the "vat_amount" field.
func (m *InvoiceItemMutation) ResetVatAmount() {
	m.vat_amount = nil
	m.addvat_amount = nil
}

// SetInvoiceID sets the "invoice" edge to the Invoice entity by id.
func (m *InvoiceItemMutation) SetInvoiceID(id uuid.UUID) {
	m.invoice = &id
}

// ClearInvoice clears the "invoice" edge to the Invoice entity.
func (m *InvoiceItemMutation) ClearInvoice() {
	m.clearedinvoice = true
}

// InvoiceCleared reports if the "invoice" edge to the Invoice entity was cleared.
func (m *InvoiceItemMutation) InvoiceCleared() bool {
	return m.clearedinvoice
}

// InvoiceID returns the "invoice" edge ID in the mutation.
func (m *InvoiceItemMutation) InvoiceID() (id uuid.UUID, exists bool) {
	if m.invoice != nil {
		return *m.invoice, true
	}
	return
}

// InvoiceIDs returns the "invoice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoiceID instead. It exists only for internal usage by the builders.
func (m *InvoiceItemMutation) InvoiceIDs() (ids []uuid.UUID) {
	if id := m.invoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoice resets all changes to the "invoice" edge.
func (m *InvoiceItemMutation) ResetInvoice() {
	m.invoice = nil
	m.clearedinvoice = false
}

// Where appends a list predicates to the InvoiceItemMutation builder.
func (m *InvoiceItemMutation) Where(ps ...predicate.InvoiceItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoiceItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoiceItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvoiceItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoiceItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoiceItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvoiceItem).
func (m *InvoiceItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoiceItemMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.description != nil {
		fields = append(fields, invoiceitem.FieldDescription)
	}
	if m.quantity != nil {
		fields = append(fields, invoiceitem.FieldQuantity)
	}
	if m.unit_price != nil {
		fields = append(fields, invoiceitem.FieldUnitPrice)
	}
	if m.amount != nil {
		fields = append(fields, invoiceitem.FieldAmount)
	}
	if m.vat_rate != nil {
		fields = append(fields, invoiceitem.FieldVatRate)
	}
	if m.vat_amount != nil {
		fields = append(fields, invoiceitem.FieldVatAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoiceItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoiceitem.FieldDescription:
		return m.Description()
	case invoiceitem.FieldQuantity:
		return m.Quantity()
	case invoiceitem.FieldUnitPrice:
		return m.UnitPrice()
	case invoiceitem.FieldAmount:
		return m.Amount()
	case invoiceitem.FieldVatRate:
		return m.VatRate()
	case invoiceitem.FieldVatAmount:
		return m.VatAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoiceItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoiceitem.FieldDescription:
		return m.OldDescription(ctx)
	case invoiceitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case invoiceitem.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case invoiceitem.FieldAmount:
		return m.OldAmount(ctx)
	case invoiceitem.FieldVatRate:
		return m.OldVatRate(ctx)
	case invoiceitem.FieldVatAmount:
		return m.OldVatAmount(ctx)
	}
	return nil, fmt.Errorf("unknown InvoiceItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoiceitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case invoiceitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case invoiceitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case invoiceitem.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case invoiceitem.FieldVatRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVatRate(v)
		return nil
	case invoiceitem.FieldVatAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVatAmount(v)
		return nil
	}
	return fmt.Errorf("unknown InvoiceItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoiceItemMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, invoiceitem.FieldQuantity)
	}
	if m.addunit_price != nil {
		fields = append(fields, invoiceitem.FieldUnitPrice)
	}
	if m.addamount != nil {
		fields = append(fields, invoiceitem.FieldAmount)
	}
	if m.addvat_rate != nil {
		fields = append(fields, invoiceitem.FieldVatRate)
	}
	if m.addvat_amount != nil {
		fields = append(fields, invoiceitem.FieldVatAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoiceItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invoiceitem.FieldQuantity:
		return m.AddedQuantity()
	case invoiceitem.FieldUnitPrice:
		return m.AddedUnitPrice()
	case invoiceitem.FieldAmount:
		return m.AddedAmount()
	case invoiceitem.FieldVatRate:
		return m.AddedVatRate()
	case invoiceitem.FieldVatAmount:
		return m.AddedVatAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invoiceitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case invoiceitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitPrice(v)
		return nil
	case invoiceitem.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case invoiceitem.FieldVatRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVatRate(v)
		return nil
	case invoiceitem.FieldVatAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVatAmount(v)
		return nil
	}
	return fmt.Errorf("unknown InvoiceItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoiceItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoiceItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoiceItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvoiceItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoiceItemMutation) ResetField(name string) error {
	switch name {
	case invoiceitem.FieldDescription:
		m.ResetDescription()
		return nil
	case invoiceitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case invoiceitem.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case invoiceitem.FieldAmount:
		m.ResetAmount()
		return nil
	case invoiceitem.FieldVatRate:
		m.ResetVatRate()
		return nil
	case invoiceitem.FieldVatAmount:
		m.ResetVatAmount()
		return nil
	}
	return fmt.Errorf("unknown InvoiceItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoiceItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.invoice != nil {
		edges = append(edges, invoiceitem.EdgeInvoice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoiceItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invoiceitem.EdgeInvoice:
		if id := m.invoice; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoiceItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoiceItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoiceItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinvoice {
		edges = append(edges, invoiceitem.EdgeInvoice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoiceItemMutation) EdgeCleared(name string) bool {
	switch name {
	case invoiceitem.EdgeInvoice:
		return m.clearedinvoice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoiceItemMutation) ClearEdge(name string) error {
	switch name {
	case invoiceitem.EdgeInvoice:
		m.ClearInvoice()
		return nil
	}
	return fmt.Errorf("unknown InvoiceItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoiceItemMutation) ResetEdge(name string) error {
	switch name {
	case invoiceitem.EdgeInvoice:
		m.ResetInvoice()
		return nil
	}
	return fmt.Errorf("unknown InvoiceItem edge %s", name)
}

// IssuerMutation represents an operation that mutates the Issuer nodes in the graph.
type IssuerMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name            *string
	joined_at       *time.Time
	clearedFields   map[string]struct{}
	invoices        map[uuid.UUID]struct{}
	removedinvoices map[uuid.UUID]struct{}
	clearedinvoices bool
	balance         *uuid.UUID
	clearedbalance  bool
	done            bool
	oldValue        func(context.Context) (*Issuer, error)
	predicates      []predicate.Issuer
}

var _ ent.Mutation = (*IssuerMutation)(nil)

// issuerOption allows management of the mutation configuration using functional options.
type issuerOption func(*IssuerMutation)

// newIssuerMutation creates new mutation for the Issuer entity.
func newIssuerMutation(c config, op Op, opts ...issuerOption) *IssuerMutation {
	m := &IssuerMutation{
		config:        c,
		op:            op,
		typ:           TypeIssuer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIssuerID sets the ID field of the mutation.
func withIssuerID(id uuid.UUID) issuerOption {
	return func(m *IssuerMutation) {
		var (
			err   error
			once  sync.Once
			value *Issuer
		)
		m.oldValue = func(ctx context.Context) (*Issuer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Issuer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIssuer sets the old Issuer of the mutation.
func withIssuer(node *Issuer) issuerOption {
	return func(m *IssuerMutation) {
		m.oldValue = func(context.Context) (*Issuer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IssuerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IssuerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Issuer entities.
func (m *IssuerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IssuerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IssuerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Issuer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *IssuerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IssuerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IssuerMutation) ResetName() {
	m.name = nil
}

// SetJoinedAt sets the "joined_at" field.
func (m *IssuerMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *IssuerMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the Issuer entity.
// If the Issuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssuerMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *IssuerMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// AddInvoiceIDs adds the "invoices" edge to the Invoice entity by ids.
func (m *IssuerMutation) AddInvoiceIDs(ids ...uuid.UUID) {
	if m.invoices == nil {
		m.invoices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invoices[ids[i]] = struct{}{}
	}
}

// ClearInvoices clears the "invoices" edge to the Invoice entity.
func (m *IssuerMutation) ClearInvoices() {
	m.clearedinvoices = true
}

// InvoicesCleared reports if the "invoices" edge to the Invoice entity was cleared.
func (m *IssuerMutation) InvoicesCleared() bool {
	return m.clearedinvoices
}

// RemoveInvoiceIDs removes the "invoices" edge to the Invoice entity by IDs.
func (m *IssuerMutation) RemoveInvoiceIDs(ids ...uuid.UUID) {
	if m.removedinvoices == nil {
		m.removedinvoices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invoices, ids[i])
		m.removedinvoices[ids[i]] = struct{}{}
	}
}

// RemovedInvoices returns the removed IDs of the "invoices" edge to the Invoice entity.
func (m *IssuerMutation) RemovedInvoicesIDs() (ids []uuid.UUID) {
	for id := range m.removedinvoices {
		ids = append(ids, id)
	}
	return
}

// InvoicesIDs returns the "invoices" edge IDs in the mutation.
func (m *IssuerMutation) InvoicesIDs() (ids []uuid.UUID) {
	for id := range m.invoices {
		ids = append(ids, id)
	}
	return
}

// ResetInvoices resets all changes to the "invoices" edge.
func (m *IssuerMutation) ResetInvoices() {
	m.invoices = nil
	m.clearedinvoices = false
	m.removedinvoices = nil
}

// SetBalanceID sets the "balance" edge to the Balance entity by id.
func (m *IssuerMutation) SetBalanceID(id uuid.UUID) {
	m.balance = &id
}

// ClearBalance clears the "balance" edge to the Balance entity.
func (m *IssuerMutation) ClearBalance() {
	m.clearedbalance = true
}

// BalanceCleared reports if the "balance" edge to the Balance entity was cleared.
func (m *IssuerMutation) BalanceCleared() bool {
	return m.clearedbalance
}

// BalanceID returns the "balance" edge ID in the mutation.
func (m *IssuerMutation) BalanceID() (id uuid.UUID, exists bool) {
	if m.balance != nil {
		return *m.balance, true
	}
	return
}

// BalanceIDs returns the "balance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BalanceID instead. It exists only for internal usage by the builders.
func (m *IssuerMutation) BalanceIDs() (ids []uuid.UUID) {
	if id := m.balance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBalance resets all changes to the "balance" edge.
func (m *IssuerMutation) ResetBalance() {
	m.balance = nil
	m.clearedbalance = false
}

// Where appends a list predicates to the IssuerMutation builder.
func (m *IssuerMutation) Where(ps ...predicate.Issuer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IssuerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IssuerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Issuer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IssuerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IssuerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Issuer).
func (m *IssuerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IssuerMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, issuer.FieldName)
	}
	if m.joined_at != nil {
		fields = append(fields, issuer.FieldJoinedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IssuerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case issuer.FieldName:
		return m.Name()
	case issuer.FieldJoinedAt:
		return m.JoinedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IssuerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case issuer.FieldName:
		return m.OldName(ctx)
	case issuer.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Issuer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssuerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case issuer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case issuer.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Issuer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IssuerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IssuerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssuerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Issuer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IssuerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IssuerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IssuerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Issuer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IssuerMutation) ResetField(name string) error {
	switch name {
	case issuer.FieldName:
		m.ResetName()
		return nil
	case issuer.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	}
	return fmt.Errorf("unknown Issuer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IssuerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.invoices != nil {
		edges = append(edges, issuer.EdgeInvoices)
	}
	if m.balance != nil {
		edges = append(edges, issuer.EdgeBalance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IssuerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case issuer.EdgeInvoices:
		ids := make([]ent.Value, 0, len(m.invoices))
		for id := range m.invoices {
			ids = append(ids, id)
		}
		return ids
	case issuer.EdgeBalance:
		if id := m.balance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IssuerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinvoices != nil {
		edges = append(edges, issuer.EdgeInvoices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IssuerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case issuer.EdgeInvoices:
		ids := make([]ent.Value, 0, len(m.removedinvoices))
		for id := range m.removedinvoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IssuerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinvoices {
		edges = append(edges, issuer.EdgeInvoices)
	}
	if m.clearedbalance {
		edges = append(edges, issuer.EdgeBalance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IssuerMutation) EdgeCleared(name string) bool {
	switch name {
	case issuer.EdgeInvoices:
		return m.clearedinvoices
	case issuer.EdgeBalance:
		return m.clearedbalance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IssuerMutation) ClearEdge(name string) error {
	switch name {
	case issuer.EdgeBalance:
		m.ClearBalance()
		return nil
	}
	return fmt.Errorf("unknown Issuer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IssuerMutation) ResetEdge(name string) error {
	switch name {
	case issuer.EdgeInvoices:
		m.ResetInvoices()
		return nil
	case issuer.EdgeBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown Issuer edge %s", name)
}

// LedgerMutation represents an operation that mutates the Ledger nodes in the graph.
type LedgerMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	status        *ledger.Status
	invoice_id    *uuid.UUID
	entity        *ledger.Entity
	entity_id     *uuid.UUID
	amount        *float64
	addamount     *float64
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Ledger, error)
	predicates    []predicate.Ledger
}

var _ ent.Mutation = (*LedgerMutation)(nil)

// ledgerOption allows management of the mutation configuration using functional options.
type ledgerOption func(*LedgerMutation)

// newLedgerMutation creates new mutation for the Ledger entity.
func newLedgerMutation(c config, op Op, opts ...ledgerOption) *LedgerMutation {
	m := &LedgerMutation{
		config:        c,
		op:            op,
		typ:           TypeLedger,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLedgerID sets the ID field of the mutation.
func withLedgerID(id uuid.UUID) ledgerOption {
	return func(m *LedgerMutation) {
		var (
			err   error
			once  sync.Once
			value *Ledger
		)
		m.oldValue = func(ctx context.Context) (*Ledger, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ledger.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLedger sets the old Ledger of the mutation.
func withLedger(node *Ledger) ledgerOption {
	return func(m *LedgerMutation) {
		m.oldValue = func(context.Context) (*Ledger, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LedgerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LedgerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ledger entities.
func (m *LedgerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LedgerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LedgerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ledger.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *LedgerMutation) SetStatus(l ledger.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LedgerMutation) Status() (r ledger.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldStatus(ctx context.Context) (v ledger.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LedgerMutation) ResetStatus() {
	m.status = nil
}

// SetInvoiceID sets the "invoice_id" field.
func (m *LedgerMutation) SetInvoiceID(u uuid.UUID) {
	m.invoice_id = &u
}

// InvoiceID returns the value of the "invoice_id" field in the mutation.
func (m *LedgerMutation) InvoiceID() (r uuid.UUID, exists bool) {
	v := m.invoice_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoice_id" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldInvoiceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// ResetInvoiceID resets all changes to the "invoice_id" field.
func (m *LedgerMutation) ResetInvoiceID() {
	m.invoice_id = nil
}

// SetEntity sets the "entity" field.
func (m *LedgerMutation) SetEntity(l ledger.Entity) {
	m.entity = &l
}

// Entity returns the value of the "entity" field in the mutation.
func (m *LedgerMutation) Entity() (r ledger.Entity, exists bool) {
	v := m.entity
	if v == nil {
		return
	}
	return *v, true
}

// OldEntity returns the old "entity" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldEntity(ctx context.Context) (v ledger.Entity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntity: %w", err)
	}
	return oldValue.Entity, nil
}

// ResetEntity resets all changes to the "entity" field.
func (m *LedgerMutation) ResetEntity() {
	m.entity = nil
}

// SetEntityID sets the "entity_id" field.
func (m *LedgerMutation) SetEntityID(u uuid.UUID) {
	m.entity_id = &u
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *LedgerMutation) EntityID() (r uuid.UUID, exists bool) {
	v := m.entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldEntityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *LedgerMutation) ResetEntityID() {
	m.entity_id = nil
}

// SetAmount sets the "amount" field.
func (m *LedgerMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *LedgerMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *LedgerMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *LedgerMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *LedgerMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LedgerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LedgerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LedgerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LedgerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LedgerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ledger entity.
// If the Ledger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LedgerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the LedgerMutation builder.
func (m *LedgerMutation) Where(ps ...predicate.Ledger) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LedgerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LedgerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ledger, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LedgerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LedgerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ledger).
func (m *LedgerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LedgerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.status != nil {
		fields = append(fields, ledger.FieldStatus)
	}
	if m.invoice_id != nil {
		fields = append(fields, ledger.FieldInvoiceID)
	}
	if m.entity != nil {
		fields = append(fields, ledger.FieldEntity)
	}
	if m.entity_id != nil {
		fields = append(fields, ledger.FieldEntityID)
	}
	if m.amount != nil {
		fields = append(fields, ledger.FieldAmount)
	}
	if m.created_at != nil {
		fields = append(fields, ledger.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ledger.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LedgerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ledger.FieldStatus:
		return m.Status()
	case ledger.FieldInvoiceID:
		return m.InvoiceID()
	case ledger.FieldEntity:
		return m.Entity()
	case ledger.FieldEntityID:
		return m.EntityID()
	case ledger.FieldAmount:
		return m.Amount()
	case ledger.FieldCreatedAt:
		return m.CreatedAt()
	case ledger.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LedgerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ledger.FieldStatus:
		return m.OldStatus(ctx)
	case ledger.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	case ledger.FieldEntity:
		return m.OldEntity(ctx)
	case ledger.FieldEntityID:
		return m.OldEntityID(ctx)
	case ledger.FieldAmount:
		return m.OldAmount(ctx)
	case ledger.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ledger.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ledger field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ledger.FieldStatus:
		v, ok := value.(ledger.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ledger.FieldInvoiceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	case ledger.FieldEntity:
		v, ok := value.(ledger.Entity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntity(v)
		return nil
	case ledger.FieldEntityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case ledger.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case ledger.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ledger.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ledger field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LedgerMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, ledger.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LedgerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ledger.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ledger.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Ledger numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LedgerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LedgerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LedgerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ledger nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LedgerMutation) ResetField(name string) error {
	switch name {
	case ledger.FieldStatus:
		m.ResetStatus()
		return nil
	case ledger.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	case ledger.FieldEntity:
		m.ResetEntity()
		return nil
	case ledger.FieldEntityID:
		m.ResetEntityID()
		return nil
	case ledger.FieldAmount:
		m.ResetAmount()
		return nil
	case ledger.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ledger.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Ledger field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LedgerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LedgerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LedgerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LedgerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LedgerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LedgerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LedgerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Ledger unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LedgerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Ledger edge %s", name)
}
